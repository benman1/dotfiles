# Name: csrc
# Copies all files in a directory (default: src) to clipboard with paths and contents
# Compatible with: macOS, Linux, WSL, Git Bash, MSYS2

set -euo pipefail

usage() {
  echo "Usage: csrc [-r] [directory]"
  echo "  -r    Recurse into subdirectories"
  echo "Copies file paths and contents of files in the directory to clipboard"
  exit 1
}

# Detect platform and set commands
detect_platform() {
  local os_type=$(uname -s)
  
  case "$os_type" in
    Darwin*)
      PLATFORM="macos"
      REALPATH_CMD="realpath"
      STAT_CMD="stat -f%z"
      ;;
    Linux*)
      if grep -qi microsoft /proc/version 2>/dev/null; then
        PLATFORM="wsl"
      else
        PLATFORM="linux"
      fi
      REALPATH_CMD="realpath --canonicalize-existing"
      STAT_CMD="stat -c%s"
      ;;
    MINGW*|MSYS*|CYGWIN*)
      PLATFORM="windows"
      REALPATH_CMD="realpath"
      STAT_CMD="stat -c%s"
      ;;
    *)
      PLATFORM="unknown"
      REALPATH_CMD="realpath"
      STAT_CMD="stat -c%s"
      ;;
  esac
  
  export PLATFORM REALPATH_CMD STAT_CMD
}

# Find appropriate clipboard command
find_clipboard_cmd() {
  if command -v clip.exe &> /dev/null; then
    echo "clip.exe"
  elif command -v pbcopy &> /dev/null; then
    echo "pbcopy"
  elif command -v xclip &> /dev/null; then
    echo "xclip -selection clipboard"
  else
    echo ""
  fi
}

# Format bytes for human readability (fallback if numfmt unavailable)
format_bytes() {
  local bytes=$1
  if command -v numfmt &> /dev/null; then
    numfmt --to=iec-i --suffix=B "$bytes"
  else
    awk -v bytes="$bytes" 'BEGIN {
      if (bytes >= 1073741824) printf "%.1fGiB\n", bytes/1073741824
      else if (bytes >= 1048576) printf "%.1fMiB\n", bytes/1048576
      else if (bytes >= 1024) printf "%.1fKiB\n", bytes/1024
      else printf "%dB\n", bytes
    }'
  fi
}

# Check if file is binary (improved, platform-agnostic)
# Check if file is binary (robust, platform-agnostic)
is_binary() {
  local file="$1"

  # Empty file -> treat as text (fixes inode/x-empty; charset=binary)
  if [ ! -s "$file" ]; then
    return 1
  fi

  # If file(1) exists, use its MIME output first (more reliable)
  if command -v file &> /dev/null; then
    local mime
    mime=$(file --mime -b "$file" 2>/dev/null) || mime=""

    if [ -n "$mime" ]; then
      # If file explicitly says charset=binary -> binary
      if echo "$mime" | grep -qiE 'charset=binary|charset=unknown-8bit'; then
        return 0
      fi

      # text/* is text
      if echo "$mime" | grep -qiE '^text/'; then
        return 1
      fi

      # application/* that are textual-ish
      if echo "$mime" | grep -qiE '^application/'; then
        if echo "$mime" | grep -qiE 'json|xml|javascript|ecmascript|x-www-form-urlencoded|sql|yaml|toml'; then
          return 1
        fi
        # otherwise leave to further checks (some application/* may be binary)
      fi

      # obvious binary types
      if echo "$mime" | grep -qiE '^(image/|audio/|video/)|font|pdf|zip|gzip|x-zip|octet-stream'; then
        return 0
      fi
      # else fall through to additional heuristics
    fi
  fi

  # Quick null byte check (cheap and definitive)
  if head -c 512 "$file" 2>/dev/null | grep -q $'\x00'; then
    return 0
  fi

  # If the file is valid UTF-8, treat as text (handles Python/source files)
  if command -v iconv &> /dev/null; then
    if iconv -f UTF-8 -t UTF-8 "$file" >/dev/null 2>&1; then
      return 1
    fi
  fi

  # Heuristic: printable ASCII ratio in first chunk (4096 bytes)
  local chunk_bytes printable total ratio
  chunk_bytes=$(head -c 4096 "$file" 2>/dev/null) || chunk_bytes=""
  if [ -z "$chunk_bytes" ]; then
    return 1
  fi

  total=$(printf '%s' "$chunk_bytes" | wc -c)
  printable=$(printf '%s' "$chunk_bytes" | tr -cd '\11\12\15\40-\176' | wc -c)
  if [ "$total" -eq 0 ]; then
    return 1
  fi

  ratio=$(( (printable * 100) / total ))

  # If less than 90% printable ASCII, treat as binary (90% is conservative)
  if [ "$ratio" -lt 90 ]; then
    return 0
  fi

  return 1
}

# Process individual file
process_file() {
  local file="$1"
  local full_path
  local file_size
  
  # Get absolute path
  full_path=$($REALPATH_CMD "$file" 2>/dev/null) || {
    echo "Error: Cannot resolve path: $file" >&2
    return 1
  }
  
  # Check readability
  if [ ! -r "$full_path" ]; then
    echo "Error: File not readable: $full_path" >&2
    return 1
  fi
  
  # Get file size
  file_size=$($STAT_CMD "$full_path" 2>/dev/null) || {
    echo "Error: Cannot get size for: $full_path" >&2
    return 1
  }
  
  # Warn on large files (>1MB)
  if [ "$file_size" -gt 1048576 ]; then
    local size_formatted=$(format_bytes "$file_size")
    echo "Warning: Large file ($size_formatted): $full_path" >&2
    read -p "Include this file? (y/n): " confirm < /dev/tty
    [[ "$confirm" != [yY] ]] && return 0
  fi
  
  # Check if binary
  if is_binary "$full_path"; then
    echo "Warning: Binary file detected: $full_path" >&2
    read -p "Include this file? (y/n): " confirm < /dev/tty
    [[ "$confirm" != [yY] ]] && return 0
  fi
  
  # Append to temp file
  echo -e "File: $full_path\nContent:" >> "$temp_file"
  cat "$full_path" >> "$temp_file" 2>/dev/null || {
    echo "Error: Failed to read: $full_path" >&2
    return 1
  }
  echo -e "\n" >> "$temp_file"
  
  return 0
}

# Main execution
main() {
  # Detect platform
  detect_platform
  
  local recursive=0

  while getopts ":r" opt; do
    case "$opt" in
      r) recursive=1 ;;
      *) usage ;;
    esac
  done
  shift $((OPTIND - 1))

  # Find clipboard command
  CLIP_CMD=$(find_clipboard_cmd)
  if [ -z "$CLIP_CMD" ]; then
    echo "Error: No clipboard command found." >&2
    echo "Please install: clip.exe (WSL), pbcopy (macOS), or xclip (Linux)" >&2
    exit 1
  fi
  
  # Set target directory
  local target_dir="${1:-src}"

  
  # Validate directory
  if [ ! -d "$target_dir" ]; then
    echo "Error: Directory not found: $target_dir" >&2
    exit 1
  fi
  
  if [ ! -r "$target_dir" ]; then
    echo "Error: Directory not readable: $target_dir" >&2
    exit 1
  fi
  
  # Create temp file
  temp_file=$(mktemp) || {
    echo "Error: Failed to create temp file" >&2
    exit 1
  }
  
  # Ensure cleanup on exit
  trap "rm -f '$temp_file'" EXIT
  
  # Process files (using process substitution to avoid subshell)
  local file_count=0
  local error_count=0
  
  if [ "$recursive" -eq 1 ]; then
    find_cmd=(find "$target_dir" -type f -print0)
  else
    find_cmd=(find "$target_dir" -maxdepth 1 -type f -print0)
  fi

  while IFS= read -r -d '' file; do
    if process_file "$file"; then
      ((file_count++))
    else
      ((error_count++))
    fi
  done < <("${find_cmd[@]}")

  # Copy to clipboard
  if [ -s "$temp_file" ]; then
    if cat "$temp_file" | $CLIP_CMD; then
      echo "Success! $file_count file(s) copied to clipboard."
      [ "$error_count" -gt 0 ] && echo "Warning: $error_count file(s) had errors." >&2
    else
      echo "Error: Clipboard copy failed using '$CLIP_CMD'" >&2
      exit 1
    fi
  else
    echo "No files were selected for copying." >&2
    exit 1
  fi
}

# Run main function
main "$@"
